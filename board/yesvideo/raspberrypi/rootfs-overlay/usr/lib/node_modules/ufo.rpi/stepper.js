var gpio = require('rpi-gpio');
var pins = require('./pins');
var NanoTimer = require('nanotimer');

var currentStep = 0
var stepIndexesOn = [
    [0],
    [0,1],
    [1],
    [1,2],
    [2],
    [2,3],
    [3],
    [3,0]
];
var numSteps = stepIndexesOn.length;
var stepsOn = [];
var stepsOff = [];

var DEFAULT_DELAY_US = 10;

var STEPS_PER_DEGREE = 4096 / 360;

var MAX_POSITION = 90 * STEPS_PER_DEGREE;

var timer = new NanoTimer();

var position = 0;

var moveToCallback = null;

function reset(cb) {
    stepsOn = stepIndexesOn.map(function(ixs) {return ixs.map(function(ix) {return pins.steppers[ix];}); });
    stepsOff = stepsOn.map(function(pinsOn) {
        var pinsOff = [];
        pins.steppers.forEach(function(pin) {
            if (pinsOn.indexOf(pin) < 0) {
                pinsOff.push(pin);
            }
        });
       return pinsOff;
    });

    position = 0;
    timer.clearInterval();
    gpio.setup(pins.limit1, gpio.DIR_IN, null, function() {
        pins.steppers.forEach(function(pin, i) {
            gpio.setup(pin, gpio.DIR_OUT, null, function() {
                gpio.write(pin, 0, (i == pins.steppers.length - 1) && cb);
            });
        });
    });
}

function step() {
    stepsOn[currentStep].forEach(function(pin) { gpio.write(pin, 1); });
    stepsOff[currentStep].forEach(function(pin) { gpio.write(pin, 0); });
}

function stepForward() {
    if (position <= MAX_POSITION) {
        currentStep = (currentStep + 1) % numSteps;
        position++;
        step();
    }
}

function stepReverse() {
    currentStep = (((currentStep - 1) % numSteps) + numSteps) % numSteps; // javascript % returns negative numbers
    position--;
    step();
}

function forward(delayUs) {
    stop();
    timer.setInterval(stepForward, null, (delayUs || DEFAULT_DELAY_US) + 'u');
}

function reverse(delayUs) {
    stop();
    timer.setInterval(stepReverse, null, (delayUs || DEFAULT_DELAY_US) + 'u');
}

function stop() {
    timer.clearInterval();

    pins.steppers.forEach(function(pin) {
        gpio.write(pin, 0);
    });

    if (moveToCallback != null) {
        moveToCallback(false, position);
        moveToCallback = null;
    }
}

function moveTo(tgtDegrees, cb, delayUs) {
    move(tgtDegrees * STEPS_PER_DEGREE, cb, delayUs);
}

function move(tgtPosition, cb, delayUs) {
    tgtPosition = Math.max(0, Math.min(MAX_POSITION, Math.floor(tgtPosition / 2) * 2 + 1));
    
    stop();
    moveToCallback = cb;
    timer.setInterval(function() {
            if (position < tgtPosition) {
                stepForward();
            }
            else if (position > tgtPosition) {
                stepReverse();
            }
            else {
                moveToCallback = null;
                stop();
                cb && cb(true, position);
            }
        }, null, (delayUs || DEFAULT_DELAY_US) + 'u');
}

function checkLimit(cb) {
    cb && gpio.read(pins.limit1, cb);
}

function home(cb, delayUs) {
    function reverseToLimit(reverseCb) {
        checkLimit(function(err, nlimit) {
            if (err || !nlimit) {
                reverseCb(err);
            }
            else {
                stepReverse();
                timer.setTimeout(reverseToLimit, [reverseCb], (delayUs || DEFAULT_DELAY_US) + 'u');
            }
        });
    }

    reverseToLimit(function(err) {
        if (err) {
            cb && cb(err);
        }
        else {
            position = 0;
            moveTo(15, function() {
                reverseToLimit(function(err) {
                    position = 0;
                    cb && cb(err);
                });
            }, delayUs);
        }
    });
}

module.exports = {
    MAX_DEGREES: (MAX_POSITION / STEPS_PER_DEGREE),
    reset: reset,
    stop: stop,
    moveTo: moveTo,
    home: home
};


function test(incr, delayUs) {
    var tgts = [0, 90];
    var curTgt = 0;
    
    tgt = tgts[curTgt];
    
    function setup() {
        var dir = (tgt > position) ? 1 : -1;
        incr = incr || 10;
        incr = incr * dir;
    }
    setup();

    var i = 0;
    var startTime = new Date().getTime();

    var testMove = function(succ) {
        if (succ == false) {
            return
        }
        
        if ((incr > 0 && position < tgt) || (incr < 0 && position > tgt)) {
            setImmediate(function() { 
                var to = incr > 0 ? Math.max(tgt, position + incr) : Math.min(tgt, position + incr);
                moveTo(to, testMove, delayUs); 
            });
        }
        else {
            i++;
            console.log("# " + i + " in " + ((new Date().getTime() - startTime) / 1000));
            tgt = tgts[++curTgt % tgts.length];
            setup();
            setImmediate(testMove);
        }
    }
    testMove();
}
