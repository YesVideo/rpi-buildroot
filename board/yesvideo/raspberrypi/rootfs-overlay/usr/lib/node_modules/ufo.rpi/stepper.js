var Promise = require('bluebird');
var gpio = Promise.promisifyAll(require('rpi-gpio'));
var pins = require('./pins');
var NanoTimer = require('nanotimer');

pins.steppers = [37, 21, 23, 24];

var currentStep = 0
var stepIndexesOn = [
    [0],
    [0,1],
    [1],
    [1,2],
    [2],
    [2,3],
    [3],
    [3,0]
];
var numSteps = stepIndexesOn.length;
var stepsOn = [];
var stepsOff = [];

// controls the delay between steps; too short a delay will cause skips
var DEFAULT_DELAY_US = 10;
var delayUs = DEFAULT_DELAY_US;

// Gear ratio is ~63.68395:1 - http://forum.arduino.cc/index.php?topic=71964.15
var STEPS_PER_ROTATION = (64 * 25792) / 405; // ~4076
var STEPS_PER_DEGREE = STEPS_PER_ROTATION / 360; // ~11.3

var MAX_POSITION = 70 * STEPS_PER_DEGREE;

var timer = new NanoTimer();

var position = 0;

var moveToCallback = null;

function setStepDelay(_delayUs) {
    delayUs = _delayUs;
}

function reset(cb) {
    stepsOn = stepIndexesOn.map(function(ixs) {return ixs.map(function(ix) {return pins.steppers[ix];}); });
    stepsOff = stepsOn.map(function(pinsOn) {
        var pinsOff = [];
        pins.steppers.forEach(function(pin) {
            if (pinsOn.indexOf(pin) < 0) {
                pinsOff.push(pin);
            }
        });
       return pinsOff;
    });

    position = 0;
    timer.clearInterval();
    gpio.setupAsync(pins.limit1, gpio.DIR_IN)
        .then(function() {
            return Promise.all(pins.steppers.map(function(pin) { return gpio.setupAsync(pin, gpio.DIR_OUT); }));
        })
        .then(function() {
            return Promise.all(pins.steppers.map(function(pin) { return gpio.writeAsync(pin, 0); }));
        })
        .then(cb)
        .catch(cb);
}

function step() {
    Promise.all(stepsOn[currentStep].map(function(pin) { return gpio.writeAsync(pin, 1); }))
        .then(function() {
            stepsOff[currentStep].forEach(function(pin) { gpio.write(pin, 0); });
        });
}

function stepForward() {
    if (position <= MAX_POSITION) {
        currentStep = (currentStep + 1) % numSteps;
        position++;
        step();
    }
}

function stepReverse() {
    currentStep = (((currentStep - 1) % numSteps) + numSteps) % numSteps; // javascript % returns negative numbers
    position--;
    step();
}

function forward() {
    stop();
    timer.setInterval(stepForward, null, delayUs + 'u');
}

function reverse() {
    stop();
    timer.setInterval(stepReverse, null, delayUs + 'u');
}

function stop() {
    timer.clearInterval();

    if (moveToCallback != null) {
        moveToCallback(null, false, position);
        moveToCallback = null;
    }
}

function moveTo(tgtDegrees, cb) {
    move(tgtDegrees * STEPS_PER_DEGREE, cb);
}

function move(tgtPosition, cb) {
    // make sure we always stop at an even position (and less than the max)
    tgtPosition = Math.max(0, Math.min(MAX_POSITION, Math.floor(tgtPosition / 2) * 2));
    
    stop();
    moveToCallback = cb;
    timer.setInterval(function() {
            if (position < tgtPosition) {
                stepForward();
            }
            else if (position > tgtPosition) {
                stepReverse();
            }
            else {
                moveToCallback = null;
                stop();
                cb && cb(null, true, position);
            }
        }, null, delayUs + 'u');
}

function checkLimit(cb) {
    cb && gpio.read(pins.limit1, cb);
}

function home(cb) {
    function reverseToLimit(reverseCb) {
        checkLimit(function(err, nlimit) {
            if (err || !nlimit) {
                reverseCb(err);
            }
            else {
                stepReverse();
                timer.setTimeout(reverseToLimit, [reverseCb], delayUs + 'u');
            }
        });
    }

    reverseToLimit(function(err) {
        if (err) {
            cb && cb(err);
        }
        else {
            position = 0;
            moveTo(15, function() {
                reverseToLimit(function(err) {
                    position = 0;
                    cb && cb(err);
                });
            }, delayUs);
        }
    });
}

module.exports = {
    MAX_DEGREES: (MAX_POSITION / STEPS_PER_DEGREE),
    setStepDelay: setStepDelay,
    reset: reset,
    stop: stop,
    moveTo: moveTo,
    home: home
};

/*
var Promise = require('bluebird');
var stepper = require('./stepper');
var laser = require('./laser');
stepper.reset(function(){stepper.home()});
laser.reset();

var moveToAsync = Promise.promisify(stepper.moveTo);
stepper.setStepDelay(3000);

var kill = false;
var tgts = [40, 41, 42, 43, 44, 45];
var curTgt = 0;
var tgt = tgts[curTgt];

stepper.moveTo(tgt, function() {laser.on()})


function twitch() {
    return moveToAsync(tgt).then(function() {
        if (!kill) {
            tgt = tgts[++curTgt % tgts.length];
            setTimeout(twitch, 100);
        }
    });
}

kill = false;
twitch();
laser.on()
kill = true;
*/
