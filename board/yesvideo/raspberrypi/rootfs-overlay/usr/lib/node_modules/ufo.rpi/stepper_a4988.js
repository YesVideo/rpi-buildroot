var Promise = require('bluebird');
var gpio = Promise.promisifyAll(require('rpi-gpio'));
var pins = require('./pins');
var NanoTimer = require('nanotimer');

var Channel = function() {
    var _this = {
        value: null
    }
    _this.set = function(v) {
        _this.value = v;
    }
    _this.get = function() {
        return _this.value;
    }
    
    return _this;
};


// controls the delay between microsteps
var ENABLE_DELAY_US = 1500;
var DEFAULT_DELAY_US = 10;
var delayUs = DEFAULT_DELAY_US;

var STEPS_PER_ROTATION = 200;
var STEPS_PER_DEGREE = STEPS_PER_ROTATION / 360;
var MICROSTEPS = 16;
var MICROSTEPS_PER_DEGREE = STEPS_PER_DEGREE * MICROSTEPS;
var MAX_DEGREES = 90;
var MAX_MICROPOSITION = MAX_DEGREES * MICROSTEPS_PER_DEGREE;

// global timer
var timer = new NanoTimer();

// current position/direction
var curPosition = 0;
var curDirectionFwd = true;
var stopSignal = null;

function setStepDelay(_delayUs) {
    delayUs = _delayUs;
}


function reset(cb) {
    curPosition = 0;
    curDirectionFwd = true;

    var setupInputs = [
            pins.limit1,
            pins.limit2
        ].map(function(pin) {
            return gpio.setupAsync(pin, gpio.DIR_IN);
        });

    var setupOutputs = [
            pins.stepper_a4988.direction,
            pins.stepper_a4988.step,
            pins.stepper_a4988.ms2,
            pins.stepper_a4988.nEnable
        ].map(function(pin) {
            return gpio.setupAsync(pin, gpio.DIR_OUT).
                then(function() {
                    gpio.write(pin, 1);
                });
        });

    return Promise.all(setupInputs.concat(setupOutputs)).
        asCallback(cb)
}

function setEnabled(enabled) {
    return gpio.writeAsync(pins.stepper_a4988.nEnable, !enabled);
}

function setDirection(isForward) {
    isForward = !!isForward;
    if (isForward == curDirectionFwd) {
        return Promise.resolve();
    }
    else {
        curDirectionFwd = isForward;
        return gpio.writeAsync(pins.stepper_a4988.direction, isForward ? 1 : 0);
    }
}

function step(cb) {
    gpio.write(pins.stepper_a4988.step, 1, function() {
        gpio.write(pins.stepper_a4988.step, 0, cb);
    });
}

function stop() {
    stopSignal && stopSignal.set(true);
    stopSignal = null;
}

function moveToDegrees(tgtDegrees, cb) {
    return moveToPosition(tgtDegrees * MICROSTEPS_PER_DEGREE).
        then(function(endPos) {
            return Promise.resolve(endPos / MICROSTEPS_PER_DEGREE);
        }).
        asCallback(cb);
}

function moveToPosition(tgtPosition) {
    stop();

    var deferred = Promise.pending();
    var stopper = Channel();
    stopSignal = stopper;

    // make sure we always stop at a full step position (and less than the max)
    tgtPosition = Math.max(0, Math.floor(Math.min(MAX_MICROPOSITION, tgtPosition) / MICROSTEPS) * MICROSTEPS);
    var dir = tgtPosition > curPosition ? 1 : -1;

    function incr() {
        step(function() {
            curPosition += dir;

            if (stopper.get() || (curPosition == tgtPosition)) {
                deferred.resolve(curPosition);
            }
            else {
                timer.setTimeout(incr, [], delayUs + 'u');
            }
        });
    }

    if (curPosition == tgtPosition) {
        deferred.resolve(curPosition);
    }
    else {
        setDirection(dir > 0).
            then(setEnabled.bind(this, true)).
            then(function() {
                timer.setTimeout(incr, [], ENABLE_DELAY_US + 'u');
            }).
            catch(deferred.reject);
            
        deferred.promise.finally(function() {
            if (stopSignal == stopper) {
                setEnabled(false);
            }
        });
    }
    
    return deferred.promise;
}

function moveAbs(n) {
    stop();

    var deferred = Promise.pending();
    var stopper = Channel();
    stopSignal = stopper;

    var dir = n > 0;
    n = Math.abs(n);

    function incr() {
        if (stopper.get() || (n-- == 0)) {
            deferred.resolve();
        }
        else {
            step(function() {
                timer.setTimeout(incr, [], delayUs + 'u');
            });
        }
    }

    setDirection(dir).
        then(setEnabled.bind(this, true)).
        then(function() {
            timer.setTimeout(incr, [], ENABLE_DELAY_US + 'u');
        }).
        catch(deferred.reject);

    deferred.promise.finally(function() {
        setEnabled(false);
    });
    
    return deferred.promise;
}

function home(cb) {
    function moveToLimit(dir, limitTgt) {
        var deferred = Promise.pending();

        function moveTest() {
            gpio.readAsync(pins.limit1).
                then(function(limit) {
                    if (limit == limitTgt) {
                        deferred.resolve();
                    }
                    else {
                        moveAbs(dir * MICROSTEPS).
                            then(moveTest).
                            catch(deferred.reject);
                    }
                });
        }
        moveTest();
        
        return deferred.promise;
    }

    // move back until limit
    return moveToLimit(-1, false).
        // move fwd until not limit
        then(moveToLimit.bind(this, 1, true)).
        // move fwd 20 more degrees
        then(moveAbs.bind(this, 10 * MICROSTEPS)).
        // move back until limit
        then(moveToLimit.bind(this, -1, false)).
        // set zero
        then(function() {
            curPosition = 0;
        }).
        asCallback(cb);
}


//TODO: watchdog on enable


module.exports = {
    MAX_DEGREES: MAX_DEGREES,
    setStepDelay: setStepDelay,
    reset: reset,
    stop: stop,
    moveTo: moveToDegrees,
    moveToPos: moveToPosition,
    moveAbs: moveAbs,
    home: home
};
