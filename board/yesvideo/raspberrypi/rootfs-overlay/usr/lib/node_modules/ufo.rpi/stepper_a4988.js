var Promise = require('bluebird');
var gpio = Promise.promisifyAll(require('rpi-gpio'));
var pins = require('./pins');
var NanoTimer = require('nanotimer');

var Channel = function() {
    var _this = {
        value: null
    }
    _this.set = function(v) {
        _this.value = v;
    }
    _this.get = function() {
        return _this.value;
    }
    
    return _this;
};


// controls the delay between microsteps
var ENABLE_DELAY_US = 1500;
var DEFAULT_DELAY_US = 10;
var delayUs = DEFAULT_DELAY_US;

var STEPS_PER_ROTATION = 200;
var STEPS_PER_DEGREE = STEPS_PER_ROTATION / 360;
var MICROSTEPS = 4;
var MICROSTEPS_PER_DEGREE = STEPS_PER_DEGREE * MICROSTEPS;
var MAX_DEGREES = 90;
var MAX_MICROPOSITION = MAX_DEGREES * MICROSTEPS_PER_DEGREE;

// global timer
var timer = new NanoTimer();

// current position/direction
var curPosition = 0;
var curDirectionFwd = true;
var stopSignal = null;

function setStepDelay(_delayUs) {
    delayUs = _delayUs;
}


function reset(cb) {
    curPosition = 0;
    curDirectionFwd = true;

    var setupInputs = [
            pins.limit1,
            pins.limit2
        ].map(function(pin) {
            return gpio.setupAsync(pin, gpio.DIR_IN);
        });

    var setupOutputs = [
            pins.stepper_a4988.direction,
            pins.stepper_a4988.step,
            pins.stepper_a4988.ms2,
            pins.stepper_a4988.nEnable
        ].map(function(pin) {
            return gpio.setupAsync(pin, gpio.DIR_OUT).
                then(function() {
                    gpio.write(pin, 1);
                });
        });

    return Promise.all(setupInputs.concat(setupOutputs)).
        asCallback(cb)
}

function setEnabled(enabled) {
    return gpio.writeAsync(pins.stepper_a4988.nEnable, !enabled);
}

function setDirection(isForward) {
    isForward = !!isForward;
    if (isForward == curDirectionFwd) {
        return Promise.resolve();
    }
    else {
        curDirectionFwd = isForward;
        return gpio.writeAsync(pins.stepper_a4988.direction, isForward ? 1 : 0);
    }
}

function step(cb) {
    gpio.write(pins.stepper_a4988.step, 1, function() {
        gpio.write(pins.stepper_a4988.step, 0, cb);
    });
}

function stop() {
    stopSignal && stopSignal.set(true);
    stopSignal = null;
}

function moveToDegrees(tgtDegrees, cb) {
    return moveToPosition(tgtDegrees * MICROSTEPS_PER_DEGREE).
        then(function(endPos) {
            return Promise.resolve(endPos / MICROSTEPS_PER_DEGREE);
        }).
        asCallback(cb);
}

function moveToPosition(tgtPosition) {
    stop();

    var deferred = Promise.pending();
    var stopper = Channel();
    stopSignal = stopper;

    // make sure we always stop at a full step position (and less than the max)
    tgtPosition = Math.max(0, Math.floor(Math.min(MAX_MICROPOSITION, tgtPosition) / MICROSTEPS) * MICROSTEPS);
    var dir = tgtPosition > curPosition ? 1 : -1;

    function incr() {
        step(function() {
            curPosition += dir;

            if (stopper.get() || (curPosition == tgtPosition)) {
                deferred.resolve(curPosition);
            }
            else {
                timer.setTimeout(incr, [], delayUs + 'u');
            }
        });
    }

    if (curPosition == tgtPosition) {
        deferred.resolve(curPosition);
    }
    else {
        setDirection(dir > 0).
            then(setEnabled.bind(this, true)).
            then(function() {
                timer.setTimeout(incr, [], ENABLE_DELAY_US + 'u');
            });
            
        deferred.promise.finally(function() {
            setEnabled(false);
        });
    }
    
    return deferred.promise;
}

function moveAbs(n) {
    stop();

    var deferred = Promise.pending();
    var stopper = Channel();
    stopSignal = stopper;

    var dir = n > 0;
    n = Math.abs(n);

    function incr() {
        if (stopper.get() || (n-- == 0)) {
            deferred.resolve();
        }
        else {
            step(function() {
                timer.setTimeout(incr, [], delayUs + 'u');
            });
        }
    }

    setDirection(dir).
        then(setEnabled.bind(this, true)).
        then(function() {
            timer.setTimeout(incr, [], ENABLE_DELAY_US + 'u');
        });

        deferred.promise.finally(function() {
            setEnabled(false);
        });
    
    return deferred.promise;
}

function home(cb) {
    var deferred = Promise.pending();

    function reverseToLimit(reverseCb) {
        gpio.read(pins.limit1, function(err, limit) {
            if (err || !limit) {
                reverseCb(err);
            }
            else {
                moveAbs(-MICROSTEPS).
                then(function() {
                    reverseToLimit(reverseCb);
                });
            }
        });
    }

    reverseToLimit(function(err) {
        if (err) {
            deferred.reject(err);
        }
        else {
            curPosition = 0;
//TODO: forward until !limit, then forward more
            moveToDegrees(20).
            then(function() {
                reverseToLimit(function(err) {
                    position = 0;
                    deferred.resolve();
                });
            });
        }
    });
    
    deferred.promise.asCallback(cb);
    
    return deferred.promise;
}


//TODO: watchdog on enable


module.exports = {
    MAX_DEGREES: MAX_DEGREES,
    setStepDelay: setStepDelay,
    reset: reset,
    stop: stop,
    moveTo: moveToDegrees,
    moveToPos: moveToPosition,
    moveAbs: moveAbs,
    home: home
};
